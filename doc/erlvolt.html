<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module erlvolt</title>
<link rel="stylesheet" type="text/css" href="erlvolt.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module erlvolt</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>.


<h2><a name="description">Description</a></h2>
  
      <p>This is the module to import into your client module to access      
VoltDB.</p>
  
      It provides you with functions to communicate with the VoltDB
      server.
  
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-column_names">column_names()</a></h3>
<p><tt>column_names() = [<a href="#type-name">name()</a>]</tt></p>


<h3 class="typedecl"><a name="type-column_type">column_type()</a></h3>
<p><tt>column_type() = [<a href="#type-volttype">volttype()</a>]</tt></p>


<h3 class="typedecl"><a name="type-erltype">erltype()</a></h3>
<p><tt>erltype() = [integer() | float() | list() | binary()]</tt></p>
<p>Target type of erl_* functions.
  </p>

<h3 class="typedecl"><a name="type-field">field()</a></h3>
<p><tt>field() = [string() | integer() | float() | null]</tt></p>


<h3 class="typedecl"><a name="type-name">name()</a></h3>
<p><tt>name() = [atom()]</tt></p>


<h3 class="typedecl"><a name="type-row">row()</a></h3>
<p><tt>row() = [<a href="#type-field">field()</a>]</tt></p>


<h3 class="typedecl"><a name="type-rows">rows()</a></h3>
<p><tt>rows() = [<a href="#type-row">row()</a>]</tt></p>


<h3 class="typedecl"><a name="type-voltresponse">voltresponse()</a></h3>
<p><tt>voltresponse() = {voltresponse, {Protocol, ClientData, Status, StatusString, AppStatus, AppStatusString, SerializedException, RoundTripTime}, [<a href="#type-volttable">volttable()</a>]}</tt></p>


<h3 class="typedecl"><a name="type-volttable">volttable()</a></h3>
<p><tt>volttable() = {volttable, <a href="#type-rows">rows()</a>, <a href="#type-column_names">column_names()</a>, <a href="#type-column_types">column_types()</a>}</tt></p>


<h3 class="typedecl"><a name="type-volttype">volttype()</a></h3>
<p><tt>volttype() = [integer()]</tt></p>


<h3 class="typedecl"><a name="type-wiretype">wiretype()</a></h3>
<p><tt>wiretype() = <a href="#type-volttype">volttype()</a> | binary()</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_callback-1">add_callback/1</a></td><td> Add a callback function to the callback list.</td></tr>
<tr><td valign="top"><a href="#banner-0">banner/0</a></td><td>Prints a banner with library name and version, and a note.</td></tr>
<tr><td valign="top"><a href="#banner-1">banner/1</a></td><td>Prints a banner with library name and version, and a note, plus message.</td></tr>
<tr><td valign="top"><a href="#callProcedure-3">callProcedure/3</a></td><td> Send a stored procedure call to the VoltDB server.</td></tr>
<tr><td valign="top"><a href="#callProcedure-4">callProcedure/4</a></td><td> Send a stored procedure call to the VoltDB server.</td></tr>
<tr><td valign="top"><a href="#callProcedure-5">callProcedure/5</a></td><td> Send a stored procedure call to the VoltDB server.</td></tr>
<tr><td valign="top"><a href="#createConnection-0">createConnection/0</a></td><td> Client opens connection and logs in to the VoltDB server cluster.</td></tr>
<tr><td valign="top"><a href="#createConnection-1">createConnection/1</a></td><td> Client opens connection and logs in to the VoltDB server cluster.</td></tr>
<tr><td valign="top"><a href="#createConnection-3">createConnection/3</a></td><td> Client opens connection and logs in to the VoltDB server cluster.</td></tr>
<tr><td valign="top"><a href="#createConnection-4">createConnection/4</a></td><td> Client opens connection and logs in to the VoltDB server cluster.</td></tr>
<tr><td valign="top"><a href="#create_callback_id-0">create_callback_id/0</a></td><td> Create an id as handle to callback functions in the callback list.</td></tr>
<tr><td valign="top"><a href="#create_callback_table-0">create_callback_table/0</a></td><td> Create the callback table.</td></tr>
<tr><td valign="top"><a href="#delete_callback-1">delete_callback/1</a></td><td>Internal: delete callback from internal callback list.</td></tr>
<tr><td valign="top"><a href="#erl_any-2">erl_any/2</a></td><td>Make an Erlang value from any VoltDB wire type, w/type specified.</td></tr>
<tr><td valign="top"><a href="#erl_bigint_feed-1">erl_bigint_feed/1</a></td><td>Make an Erlang integer from a BIGINT (64 bit) VoltDB wire type.</td></tr>
<tr><td valign="top"><a href="#erl_datetime-1">erl_datetime/1</a></td><td>VoltDB wire code time /as binary/ to Erlang 'DateTime' format.</td></tr>
<tr><td valign="top"><a href="#erl_decimal_feed-1">erl_decimal_feed/1</a></td><td>Make an Erlang value from a decimal VoltDB wire type.</td></tr>
<tr><td valign="top"><a href="#erl_float-1">erl_float/1</a></td><td> VoltDB float wire code to Erlang float - throws on NaN/Infinities.</td></tr>
<tr><td valign="top"><a href="#erl_float_feed-1">erl_float_feed/1</a></td><td>Make an Erlang float from a float VoltDB wire type.</td></tr>
<tr><td valign="top"><a href="#erl_float_or_atom-1">erl_float_or_atom/1</a></td><td> VoltDB float wire code to Erlang float - with NaN/Infinities to atoms - any 32bit.</td></tr>
<tr><td valign="top"><a href="#erl_float_or_null_from_decimal-1">erl_float_or_null_from_decimal/1</a></td><td>VoltDB binary decimals wire code to Erlang float, or null atom.</td></tr>
<tr><td valign="top"><a href="#erl_header-1">erl_header/1</a></td><td>Parse wire protocol header.</td></tr>
<tr><td valign="top"><a href="#erl_integer-1">erl_integer/1</a></td><td>VoltDB integer wire code to Erlang integer.</td></tr>
<tr><td valign="top"><a href="#erl_integer_from_decimal-1">erl_integer_from_decimal/1</a></td><td>VoltDB binary decimals wire code to Erlang integer, failing on NULL.</td></tr>
<tr><td valign="top"><a href="#erl_integer_or_null_from_decimal-1">erl_integer_or_null_from_decimal/1</a></td><td>VoltDB binary decimals wire code to Erlang integer, or null atom.</td></tr>
<tr><td valign="top"><a href="#erl_intint_feed-1">erl_intint_feed/1</a></td><td>Make an Erlang integer from an INTEGER (32 bit) VoltDB wire type.</td></tr>
<tr><td valign="top"><a href="#erl_nowtime-1">erl_nowtime/1</a></td><td>VoltDB wire code time from binary to Erlang 'Now' format.</td></tr>
<tr><td valign="top"><a href="#erl_number-1">erl_number/1</a></td><td>VoltDB binary decimals wire code to Erlang integer, failing on NULL.</td></tr>
<tr><td valign="top"><a href="#erl_number_or_null-1">erl_number_or_null/1</a></td><td>VoltDB binary decimals wire code to Erlang integer, or null atom.</td></tr>
<tr><td valign="top"><a href="#erl_plaintable-1">erl_plaintable/1</a></td><td>  Parse a VoltTable from VoltDB wire protocol data, return a once-nested list.</td></tr>
<tr><td valign="top"><a href="#erl_response-1">erl_response/1</a></td><td>Parse VoltDB server response  to stored procedure invocation.</td></tr>
<tr><td valign="top"><a href="#erl_smallint_feed-1">erl_smallint_feed/1</a></td><td>Make an Erlang integer from a SMALLINT (16 bit) VoltDB wire type.</td></tr>
<tr><td valign="top"><a href="#erl_string_or_null-1">erl_string_or_null/1</a></td><td>Erlang string (list) to VoltDB string wire code.</td></tr>
<tr><td valign="top"><a href="#erl_table-1">erl_table/1</a></td><td>  Parse a VoltTable from VoltDB wire protocol data.</td></tr>
<tr><td valign="top"><a href="#erl_time-1">erl_time/1</a></td><td>synonyms of erl_nowtime/1.</td></tr>
<tr><td valign="top"><a href="#erl_timestamp_feed-1">erl_timestamp_feed/1</a></td><td>Make an Erlang value from a timestamp VoltDB wire type.</td></tr>
<tr><td valign="top"><a href="#erl_tinyint_feed-1">erl_tinyint_feed/1</a></td><td>Make an Erlang integer from a TINYINT (8 bit) VoltDB wire type.</td></tr>
<tr><td valign="top"><a href="#erl_unixtime-1">erl_unixtime/1</a></td><td>Unix epoch seconds from VoltDB wire code time binary.</td></tr>
<tr><td valign="top"><a href="#execute_callback-2">execute_callback/2</a></td><td>Internal: execute callback from internal callback list.</td></tr>
<tr><td valign="top"><a href="#fetchRow-2">fetchRow/2</a></td><td>Get a row out of a given table, by index number.</td></tr>
<tr><td valign="top"><a href="#getField-2">getField/2</a></td><td>Get a field out of a row, by index number.</td></tr>
<tr><td valign="top"><a href="#getString-2">getString/2</a></td><td>Get a field out of a row as string, by index number.</td></tr>
<tr><td valign="top"><a href="#getString-3">getString/3</a></td><td>Get a field out of a row as string, by column name.</td></tr>
<tr><td valign="top"><a href="#get_callback-1">get_callback/1</a></td><td>Internal: find a callback function from internal callback list, or fail.</td></tr>
<tr><td valign="top"><a href="#get_callback_or_nil-1">get_callback_or_nil/1</a></td><td>Internal: find a callback function in internal callback list.</td></tr>
<tr><td valign="top"><a href="#help-0">help/0</a></td><td>Displays a brief pointer about were to get more help.</td></tr>
<tr><td valign="top"><a href="#listOrd-2">listOrd/2</a></td><td>Return index number of a given list element.</td></tr>
<tr><td valign="top"><a href="#login-3">login/3</a></td><td>Client log in to the VoltDB server cluster, blocking.</td></tr>
<tr><td valign="top"><a href="#login-4">login/4</a></td><td>Client log in to the VoltDB server cluster, blocking or non-blocking.</td></tr>
<tr><td valign="top"><a href="#milli_epoch-1">milli_epoch/1</a></td><td>actual calculation 'now' format to VoltDB wire format.</td></tr>
<tr><td valign="top"><a href="#resolve_callback-2">resolve_callback/2</a></td><td>Internal: execute and delete callback from internal callback list.</td></tr>
<tr><td valign="top"><a href="#vecho-3">vecho/3</a></td><td>Conditionally print String x Format to standard out.</td></tr>
<tr><td valign="top"><a href="#volt_array-1">volt_array/1</a></td><td>Make Erlang List to VoltDB wire binary array, explicit type.</td></tr>
<tr><td valign="top"><a href="#volt_array-2">volt_array/2</a></td><td>Make Erlang List to VoltDB wire binary array, explicit type.</td></tr>
<tr><td valign="top"><a href="#volt_bigint-1">volt_bigint/1</a></td><td>Erlang integer to VoltDB BIGINT (64 bit) wire code.</td></tr>
<tr><td valign="top"><a href="#volt_byte-1">volt_byte/1</a></td><td>Erlang integer to VoltDB TINYINT (8 bit) wire code.</td></tr>
<tr><td valign="top"><a href="#volt_decimal-1">volt_decimal/1</a></td><td>Erlang float to VoltDB binary decimals wire code.</td></tr>
<tr><td valign="top"><a href="#volt_fields-2">volt_fields/2</a></td><td>Converting two lists (Types, Contents) into a list of voltdb wire encoded binaries.</td></tr>
<tr><td valign="top"><a href="#volt_float-1">volt_float/1</a></td><td>Erlang value to VoltDB float.</td></tr>
<tr><td valign="top"><a href="#volt_hash-1">volt_hash/1</a></td><td> Make SHA-1 hash for client log in to the VoltDB server cluster.</td></tr>
<tr><td valign="top"><a href="#volt_header-0">volt_header/0</a></td><td>VoltDB message header bytes - actually protocol version only.</td></tr>
<tr><td valign="top"><a href="#volt_integer-1">volt_integer/1</a></td><td>Erlang integer to VoltDB INTEGER (32 bit) wire code.</td></tr>
<tr><td valign="top"><a href="#volt_intint-1">volt_intint/1</a></td><td>Erlang integer to VoltDB INTEGER (32 bit) wire code.</td></tr>
<tr><td valign="top"><a href="#volt_invoke-3">volt_invoke/3</a></td><td> Make VoltDB wire binary for login message from name and password.</td></tr>
<tr><td valign="top"><a href="#volt_login-2">volt_login/2</a></td><td> Make VoltDB wire binary for login message from name and password.</td></tr>
<tr><td valign="top"><a href="#volt_long-1">volt_long/1</a></td><td>Erlang integer to VoltDB BIGINT (64 bit) wire code.</td></tr>
<tr><td valign="top"><a href="#volt_parameter-1">volt_parameter/1</a></td><td> Encode, with type, one parameter for Stored Procedure Calls.</td></tr>
<tr><td valign="top"><a href="#volt_parameters-1">volt_parameters/1</a></td><td> Encode parameters for Stored Procedure Calls.</td></tr>
<tr><td valign="top"><a href="#volt_rows-2">volt_rows/2</a></td><td>Encode Erlang terms to VoltTable rows.</td></tr>
<tr><td valign="top"><a href="#volt_short-1">volt_short/1</a></td><td>Erlang integer to VoltDB SHORTINT (16 bit) wire code.</td></tr>
<tr><td valign="top"><a href="#volt_small-1">volt_small/1</a></td><td>Erlang integer to VoltDB SHORTINT (16 bit) wire code.</td></tr>
<tr><td valign="top"><a href="#volt_string-1">volt_string/1</a></td><td>VoltDB string wire code for NULL.</td></tr>
<tr><td valign="top"><a href="#volt_table-1">volt_table/1</a></td><td>Encode Erlang terms to VoltTable rows, with status code 0.</td></tr>
<tr><td valign="top"><a href="#volt_table-2">volt_table/2</a></td><td>Encode Erlang terms to VoltTable rows, with explicit status code.</td></tr>
<tr><td valign="top"><a href="#volt_time-1">volt_time/1</a></td><td>Erlang 'now format' time to VoltDB wire code time binary.</td></tr>
<tr><td valign="top"><a href="#volt_time_binary-1">volt_time_binary/1</a></td><td>Over/Underrun guards and cast to binary.</td></tr>
<tr><td valign="top"><a href="#volt_type-1">volt_type/1</a></td><td> Guessing types.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add_callback-1">add_callback/1</a></h3>
<div class="spec">
<p><tt>add_callback(Fun::function()) -&gt; Id::any()</tt></p>
</div><p> Add a callback function to the callback list.</p>

<h3 class="function"><a name="banner-0">banner/0</a></h3>
<div class="spec">
<p><tt>banner() -&gt; any()</tt></p>
</div><p>Prints a banner with library name and version, and a note.</p>

<h3 class="function"><a name="banner-1">banner/1</a></h3>
<div class="spec">
<p><tt>banner(Message) -&gt; any()</tt></p>
</div><p>Prints a banner with library name and version, and a note, plus message.</p>

<h3 class="function"><a name="callProcedure-3">callProcedure/3</a></h3>
<div class="spec">
<p><tt>callProcedure(Socket, ProcedureName, Parameters) -&gt; any()</tt></p>
</div><p> Send a stored procedure call to the VoltDB server.
   Use a default client tag and default time out.</p>

<h3 class="function"><a name="callProcedure-4">callProcedure/4</a></h3>
<div class="spec">
<p><tt>callProcedure(Socket, ProcedureName, Parameters, ClientTag) -&gt; any()</tt></p>
</div><p> Send a stored procedure call to the VoltDB server.
   Use a specified client tag and default time out.</p>

<h3 class="function"><a name="callProcedure-5">callProcedure/5</a></h3>
<div class="spec">
<p><tt>callProcedure(Socket, ProcedureName, Parameters, ClientData, TimeOut) -&gt; any()</tt></p>
</div><p> Send a stored procedure call to the VoltDB server.
   Use a specified client tag and a specified time out.</p>

<h3 class="function"><a name="createConnection-0">createConnection/0</a></h3>
<div class="spec">
<p><tt>createConnection() -&gt; any()</tt></p>
</div><p> Client opens connection and logs in to the VoltDB server cluster.
   Use defaults: localhost, port 21212, client name "program" and password "password".
   Login name and password can be irrelevant, check the VoltDB docs.</p>

<h3 class="function"><a name="createConnection-1">createConnection/1</a></h3>
<div class="spec">
<p><tt>createConnection(Host) -&gt; any()</tt></p>
</div><p> Client opens connection and logs in to the VoltDB server cluster.
   Use specified host and defaults: port 21212, client name "program" and password "password".
   Login name and password can be irrelevant, check the VoltDB docs.</p>

<h3 class="function"><a name="createConnection-3">createConnection/3</a></h3>
<div class="spec">
<p><tt>createConnection(Host, Login, Password) -&gt; any()</tt></p>
</div><p> Client opens connection and logs in to the VoltDB server cluster.
   Use specified host, login name and password, default port 21212.
   Login name and password can be irrelevant, check the VoltDB docs.</p>

<h3 class="function"><a name="createConnection-4">createConnection/4</a></h3>
<div class="spec">
<p><tt>createConnection(Host, Port, Login, Password) -&gt; any()</tt></p>
</div><p> Client opens connection and logs in to the VoltDB server cluster.
   Specify host, port, login name and password.
   Login name and password can be irrelevant, check the VoltDB docs.</p>

<h3 class="function"><a name="create_callback_id-0">create_callback_id/0</a></h3>
<div class="spec">
<p><tt>create_callback_id() -&gt; Id::any()</tt></p>
</div><p> Create an id as handle to callback functions in the callback list.</p>

<h3 class="function"><a name="create_callback_table-0">create_callback_table/0</a></h3>
<div class="spec">
<p><tt>create_callback_table() -&gt; TableId::atom()</tt></p>
</div><p> Create the callback table. Only one is expected to exist. It goes by
         the registered name of 'callback_table'.</p>

<h3 class="function"><a name="delete_callback-1">delete_callback/1</a></h3>
<div class="spec">
<p><tt>delete_callback(Id) -&gt; any()</tt></p>
</div><p>Internal: delete callback from internal callback list.</p>

<h3 class="function"><a name="erl_any-2">erl_any/2</a></h3>
<div class="spec">
<p><tt>erl_any(T::<a href="#type-volttype">volttype()</a>, Stream::binary()) -&gt; {Value::<a href="#type-erltype">erltype()</a>, Rest::binary()}</tt></p>
</div><p>Make an Erlang value from any VoltDB wire type, w/type specified.</p>

<h3 class="function"><a name="erl_bigint_feed-1">erl_bigint_feed/1</a></h3>
<div class="spec">
<p><tt>erl_bigint_feed(X1::<a href="#type-wiretype">wiretype()</a> | binary()) -&gt; {<a href="#type-erltype">erltype()</a>, Rest::binary()}</tt></p>
</div><p>Make an Erlang integer from a BIGINT (64 bit) VoltDB wire type.</p>

<h3 class="function"><a name="erl_datetime-1">erl_datetime/1</a></h3>
<div class="spec">
<p><tt>erl_datetime(V) -&gt; any()</tt></p>
</div><p>VoltDB wire code time /as binary/ to Erlang 'DateTime' format</p>

<h3 class="function"><a name="erl_decimal_feed-1">erl_decimal_feed/1</a></h3>
<div class="spec">
<p><tt>erl_decimal_feed(X1::<a href="#type-wiretype">wiretype()</a> | binary()) -&gt; {<a href="#type-erltype">erltype()</a>, Rest::binary()}</tt></p>
</div><p>Make an Erlang value from a decimal VoltDB wire type.</p>

<h3 class="function"><a name="erl_float-1">erl_float/1</a></h3>
<div class="spec">
<p><tt>erl_float(X1) -&gt; any()</tt></p>
</div><p> VoltDB float wire code to Erlang float - throws on NaN/Infinities</p>
<p><b>See also:</b> <a href="#volt_float-1">volt_float/1</a>.</p>

<h3 class="function"><a name="erl_float_feed-1">erl_float_feed/1</a></h3>
<div class="spec">
<p><tt>erl_float_feed(X1::<a href="#type-wiretype">wiretype()</a> | binary()) -&gt; {<a href="#type-erltype">erltype()</a>, Rest::binary()}</tt></p>
</div><p>Make an Erlang float from a float VoltDB wire type.</p>

<h3 class="function"><a name="erl_float_or_atom-1">erl_float_or_atom/1</a></h3>
<div class="spec">
<p><tt>erl_float_or_atom(X1) -&gt; any()</tt></p>
</div><p> VoltDB float wire code to Erlang float - with NaN/Infinities to atoms - any 32bit.</p>
<p><b>See also:</b> <a href="#volt_float-1">volt_float/1</a>.</p>

<h3 class="function"><a name="erl_float_or_null_from_decimal-1">erl_float_or_null_from_decimal/1</a></h3>
<div class="spec">
<p><tt>erl_float_or_null_from_decimal(V) -&gt; any()</tt></p>
</div><p>VoltDB binary decimals wire code to Erlang float, or null atom.</p>

<h3 class="function"><a name="erl_header-1">erl_header/1</a></h3>
<div class="spec">
<p><tt>erl_header(W::binary()) -&gt; {ProtocolVersion::integer(), Size::integer()} | <a href="#type-exception">exception({protocol_error, is, should})</a></tt></p>
</div><p>Parse wire protocol header.
   Erlang reads 4 length value bytes away by itself. See volt_header/0 (***)</p>

<h3 class="function"><a name="erl_integer-1">erl_integer/1</a></h3>
<div class="spec">
<p><tt>erl_integer(V::binary()) -&gt; integer()</tt></p>
</div><p>VoltDB integer wire code to Erlang integer</p>

<h3 class="function"><a name="erl_integer_from_decimal-1">erl_integer_from_decimal/1</a></h3>
<div class="spec">
<p><tt>erl_integer_from_decimal(V) -&gt; any()</tt></p>
</div><p>VoltDB binary decimals wire code to Erlang integer, failing on NULL.</p>

<h3 class="function"><a name="erl_integer_or_null_from_decimal-1">erl_integer_or_null_from_decimal/1</a></h3>
<div class="spec">
<p><tt>erl_integer_or_null_from_decimal(V) -&gt; any()</tt></p>
</div><p>VoltDB binary decimals wire code to Erlang integer, or null atom.</p>

<h3 class="function"><a name="erl_intint_feed-1">erl_intint_feed/1</a></h3>
<div class="spec">
<p><tt>erl_intint_feed(X1::<a href="#type-wiretype">wiretype()</a> | binary()) -&gt; {<a href="#type-erltype">erltype()</a>, Rest::binary()}</tt></p>
</div><p>Make an Erlang integer from an INTEGER (32 bit) VoltDB wire type.</p>

<h3 class="function"><a name="erl_nowtime-1">erl_nowtime/1</a></h3>
<div class="spec">
<p><tt>erl_nowtime(V::<a href="#type-wire">wire()</a> | integer()) -&gt; {Megasecs, Secs, Microsecs}</tt></p>
</div><p><p>VoltDB wire code time from binary to Erlang 'Now' format.   
Note: the 'now' format in Erlang means {Megasecs, Secs, Microsecs}.   
Because this 'now' can be confusing to read for, say, devs coming from Java,   
there are synomyms introduced, leaving the 'now' out: erl_time().</p>
  
   Alternate Variant:
   VoltDB wire code time from integer to Erlang 'Now' format.
   Integer input represents an interm'ry. step but might come in handy somewhere.
  </p>

<h3 class="function"><a name="erl_number-1">erl_number/1</a></h3>
<div class="spec">
<p><tt>erl_number(V) -&gt; any()</tt></p>
</div><p>VoltDB binary decimals wire code to Erlang integer, failing on NULL.</p>

<h3 class="function"><a name="erl_number_or_null-1">erl_number_or_null/1</a></h3>
<div class="spec">
<p><tt>erl_number_or_null(V) -&gt; any()</tt></p>
</div><p>VoltDB binary decimals wire code to Erlang integer, or null atom.</p>

<h3 class="function"><a name="erl_plaintable-1">erl_plaintable/1</a></h3>
<div class="spec">
<p><tt>erl_plaintable(Bin::binary()) -&gt; <a href="#type-volttable">volttable()</a></tt></p>
</div><p>  Parse a VoltTable from VoltDB wire protocol data, return a once-nested list.</p>

<h3 class="function"><a name="erl_response-1">erl_response/1</a></h3>
<div class="spec">
<p><tt>erl_response(W::<a href="#type-wire">wire()</a>) -&gt; <a href="#type-voltresponse">voltresponse()</a></tt></p>
</div><p>Parse VoltDB server response  to stored procedure invocation.</p>

<h3 class="function"><a name="erl_smallint_feed-1">erl_smallint_feed/1</a></h3>
<div class="spec">
<p><tt>erl_smallint_feed(X1::<a href="#type-wiretype">wiretype()</a> | binary()) -&gt; {<a href="#type-erltype">erltype()</a>, Rest::binary()}</tt></p>
</div><p>Make an Erlang integer from a SMALLINT (16 bit) VoltDB wire type.</p>

<h3 class="function"><a name="erl_string_or_null-1">erl_string_or_null/1</a></h3>
<div class="spec">
<p><tt>erl_string_or_null(X1) -&gt; any()</tt></p>
</div><p>Erlang string (list) to VoltDB string wire code</p>

<h3 class="function"><a name="erl_table-1">erl_table/1</a></h3>
<div class="spec">
<p><tt>erl_table(Bin::binary()) -&gt; <a href="#type-volttable">volttable()</a></tt></p>
</div><p>  Parse a VoltTable from VoltDB wire protocol data. The Table is
          translated into an Erlang volttable() structure. <pre>          { volttable,
  						[ColumnName, ColumnName, ...]
  						[ColumnType, ColumnType, ...]
  						[ { voltrow, [Value, Value, ...] },
  						  { voltrow, [Value, Value, ...] },
  						  ...
  						]
  		   }
  
   E.g.:
  
  	       { volttable, [&lt;&lt;"TestCol1"&gt;&gt;,&lt;&lt;"TestCol2"&gt;&gt;,&lt;&lt;"TestCol3"&gt;&gt;],
  						[?VOLT_BIGINT,?VOLT_BIGINT,?VOLT_STRING],
  
  						[ { voltrow, [42, 7, &lt;&lt;"volt"&gt;&gt;] },
  						  { voltrow, [28,13, &lt;&lt;"vorlt"&gt;&gt;] },
  						  { voltrow, [11, 1, &lt;&lt;"world"&gt;&gt;] } ] },</pre>
  </p>

<h3 class="function"><a name="erl_time-1">erl_time/1</a></h3>
<div class="spec">
<p><tt>erl_time(V) -&gt; any()</tt></p>
</div><p>synonyms of erl_nowtime/1.</p>

<h3 class="function"><a name="erl_timestamp_feed-1">erl_timestamp_feed/1</a></h3>
<div class="spec">
<p><tt>erl_timestamp_feed(X1::<a href="#type-wiretype">wiretype()</a> | binary()) -&gt; {<a href="#type-erltype">erltype()</a>, Rest::binary()}</tt></p>
</div><p>Make an Erlang value from a timestamp VoltDB wire type.</p>

<h3 class="function"><a name="erl_tinyint_feed-1">erl_tinyint_feed/1</a></h3>
<div class="spec">
<p><tt>erl_tinyint_feed(X1::<a href="#type-wiretype">wiretype()</a> | binary()) -&gt; {<a href="#type-erltype">erltype()</a>, Rest::binary()}</tt></p>
</div><p>Make an Erlang integer from a TINYINT (8 bit) VoltDB wire type.</p>

<h3 class="function"><a name="erl_unixtime-1">erl_unixtime/1</a></h3>
<div class="spec">
<p><tt>erl_unixtime(V) -&gt; any()</tt></p>
</div><p>Unix epoch seconds from VoltDB wire code time binary.</p>

<h3 class="function"><a name="execute_callback-2">execute_callback/2</a></h3>
<div class="spec">
<p><tt>execute_callback(Id, Param) -&gt; any()</tt></p>
</div><p>Internal: execute callback from internal callback list.</p>

<h3 class="function"><a name="fetchRow-2">fetchRow/2</a></h3>
<div class="spec">
<p><tt>fetchRow(X1::<a href="#type-volttable">volttable()</a>, Pos) -&gt; <a href="#type-voltrow">voltrow()</a></tt></p>
</div><p>Get a row out of a given table, by index number. First == 1.</p>

<h3 class="function"><a name="getField-2">getField/2</a></h3>
<div class="spec">
<p><tt>getField(X1::<a href="#type-voltrow">voltrow()</a>, Pos) -&gt; term()</tt></p>
</div><p>Get a field out of a row, by index number. First == 1.</p>

<h3 class="function"><a name="getString-2">getString/2</a></h3>
<div class="spec">
<p><tt>getString(X1::<a href="#type-voltrow">voltrow()</a>, Pos) -&gt; binary()</tt></p>
</div><p>Get a field out of a row as string, by index number. First == 1.</p>

<h3 class="function"><a name="getString-3">getString/3</a></h3>
<div class="spec">
<p><tt>getString(VoltRow::<a href="#type-voltrow">voltrow()</a>, VoltTable::<a href="#type-volttable">volttable()</a>, Name::Pos) -&gt; binary()</tt></p>
</div><p>Get a field out of a row as string, by column name.
   The complete VoltTable is used to exract column names from it.</p>

<h3 class="function"><a name="get_callback-1">get_callback/1</a></h3>
<div class="spec">
<p><tt>get_callback(Id) -&gt; any()</tt></p>
</div><p>Internal: find a callback function from internal callback list, or fail.</p>

<h3 class="function"><a name="get_callback_or_nil-1">get_callback_or_nil/1</a></h3>
<div class="spec">
<p><tt>get_callback_or_nil(Id) -&gt; any()</tt></p>
</div><p>Internal: find a callback function in internal callback list.</p>

<h3 class="function"><a name="help-0">help/0</a></h3>
<div class="spec">
<p><tt>help() -&gt; any()</tt></p>
</div><p>Displays a brief pointer about were to get more help.</p>

<h3 class="function"><a name="listOrd-2">listOrd/2</a></h3>
<div class="spec">
<p><tt>listOrd(Searched, List) -&gt; any()</tt></p>
</div><p>Return index number of a given list element.</p>

<h3 class="function"><a name="login-3">login/3</a></h3>
<div class="spec">
<p><tt>login(Socket, Name, Password) -&gt; any()</tt></p>
</div><p><p>Client log in to the VoltDB server cluster, blocking.</p>

    The login message is the first message a client can send to a server
    after opening a connection. A client does not need to wait for a res-
    ponse to the login message to begin sending invocation requests. <pre>    --------------------------------------------------------------------+
    |                    ... Message Header ...                         |
    ---------------------------------------------------------------------
    + "database"             String                                     |
    + User name:             String                                     |
    + SHA-1 password hash:   Binary 20                                  |
    ---------------------------------------------------------------------</pre>
    --- pg. 8+9, VoltDB Client Wire Protocol Version 0, 05/05/10 ---
</p>

<h3 class="function"><a name="login-4">login/4</a></h3>
<div class="spec">
<p><tt>login(Socket, Name, Password, Mode::blocking | atom()) -&gt; LoginResponse::term() | {ok, no_response_since_async}</tt></p>
</div><p>Client log in to the VoltDB server cluster, blocking or non-blocking.</p>

<h3 class="function"><a name="milli_epoch-1">milli_epoch/1</a></h3>
<div class="spec">
<p><tt>milli_epoch(X1) -&gt; any()</tt></p>
</div><p>actual calculation 'now' format to VoltDB wire format</p>

<h3 class="function"><a name="resolve_callback-2">resolve_callback/2</a></h3>
<div class="spec">
<p><tt>resolve_callback(Id, Param) -&gt; any()</tt></p>
</div><p>Internal: execute and delete callback from internal callback list.</p>

<h3 class="function"><a name="vecho-3">vecho/3</a></h3>
<div class="spec">
<p><tt>vecho(Condition, String, Format) -&gt; any()</tt></p>
</div><p>Conditionally print String x Format to standard out.</p>

<h3 class="function"><a name="volt_array-1">volt_array/1</a></h3>
<div class="spec">
<p><tt>volt_array(List) -&gt; any()</tt></p>
</div><p>Make Erlang List to VoltDB wire binary array, explicit type.</p>

<h3 class="function"><a name="volt_array-2">volt_array/2</a></h3>
<div class="spec">
<p><tt>volt_array(Type, List) -&gt; any()</tt></p>
</div><p>Make Erlang List to VoltDB wire binary array, explicit type.</p>

<h3 class="function"><a name="volt_bigint-1">volt_bigint/1</a></h3>
<div class="spec">
<p><tt>volt_bigint(E) -&gt; any()</tt></p>
</div><p>Erlang integer to VoltDB BIGINT (64 bit) wire code.</p>

<h3 class="function"><a name="volt_byte-1">volt_byte/1</a></h3>
<div class="spec">
<p><tt>volt_byte(E) -&gt; any()</tt></p>
</div><p>Erlang integer to VoltDB TINYINT (8 bit) wire code.</p>

<h3 class="function"><a name="volt_decimal-1">volt_decimal/1</a></h3>
<div class="spec">
<p><tt>volt_decimal(E) -&gt; any()</tt></p>
</div><p>Erlang float to VoltDB binary decimals wire code.</p>

<h3 class="function"><a name="volt_fields-2">volt_fields/2</a></h3>
<div class="spec">
<p><tt>volt_fields(Types, Values) -&gt; any()</tt></p>
</div><p>Converting two lists (Types, Contents) into a list of voltdb wire encoded binaries.
  E.g.  [?VOLT_STRING , ?VOLT_STRING], ["Test", "Test"] -&gt;  <code>[&lt;&lt;4:32,"Test"&gt;&gt;,&lt;&lt;4:32,"Test"&gt;&gt;]</code>
  This returns a list of binaries. Converting it to one binary in the end is thought to be faster.	</p>

<h3 class="function"><a name="volt_float-1">volt_float/1</a></h3>
<div class="spec">
<p><tt>volt_float(E::float() | nan | positive_infinity | negative_infinity) -&gt; <a href="#type-wiretype">wiretype()</a></tt></p>
</div><p>Erlang value to VoltDB float.</p>

<h3 class="function"><a name="volt_hash-1">volt_hash/1</a></h3>
<div class="spec">
<p><tt>volt_hash(Secret) -&gt; any()</tt></p>
</div><p> Make SHA-1 hash for client log in to the VoltDB server cluster.</p>

<h3 class="function"><a name="volt_header-0">volt_header/0</a></h3>
<div class="spec">
<p><tt>volt_header() -&gt; <a href="#type-wire">wire()</a></tt></p>
</div><p>VoltDB message header bytes - actually protocol version only.	    <pre>    ---------------------------------------------------------------------
    + Message Length:        Integer 4                                  |
    + Protocol Version:      Byte    1                                  |
    ---------------------------------------------------------------------</pre><p>    
The wire protocol header is included at the beginning of all messages.    
The length value includes the protocol version byte but not the 4 byte    
length value.</p>

    <p>--- pg. 8+9, VoltDB Client Wire Protocol Version 0, 05/05/10 ---</p>

    For Erlang,  the 4 leading length bytes  are effected by the flags of
    <code>[binary, {packet, 4}]</code>  to the <code>gen_tcp:connect call</code>.  Therefore,
    only the lone protocol version byte needs adding. (***)
</p>

<h3 class="function"><a name="volt_integer-1">volt_integer/1</a></h3>
<div class="spec">
<p><tt>volt_integer(E) -&gt; any()</tt></p>
</div><p>Erlang integer to VoltDB INTEGER (32 bit) wire code.</p>

<h3 class="function"><a name="volt_intint-1">volt_intint/1</a></h3>
<div class="spec">
<p><tt>volt_intint(E) -&gt; any()</tt></p>
</div><p>Erlang integer to VoltDB INTEGER (32 bit) wire code.</p>

<h3 class="function"><a name="volt_invoke-3">volt_invoke/3</a></h3>
<div class="spec">
<p><tt>volt_invoke(ProcedureName, Parameters, ClientData) -&gt; any()</tt></p>
</div><p> Make VoltDB wire binary for login message from name and password.</p>

<h3 class="function"><a name="volt_login-2">volt_login/2</a></h3>
<div class="spec">
<p><tt>volt_login(Name, Password) -&gt; any()</tt></p>
</div><p> Make VoltDB wire binary for login message from name and password.</p>

<h3 class="function"><a name="volt_long-1">volt_long/1</a></h3>
<div class="spec">
<p><tt>volt_long(E) -&gt; any()</tt></p>
</div><p>Erlang integer to VoltDB BIGINT (64 bit) wire code.</p>

<h3 class="function"><a name="volt_parameter-1">volt_parameter/1</a></h3>
<div class="spec">
<p><tt>volt_parameter(Value) -&gt; any()</tt></p>
</div><p> Encode, with type, one parameter for Stored Procedure Calls</p>

<h3 class="function"><a name="volt_parameters-1">volt_parameters/1</a></h3>
<div class="spec">
<p><tt>volt_parameters(Parameters) -&gt; any()</tt></p>
</div><p> Encode parameters for Stored Procedure Calls</p>

<h3 class="function"><a name="volt_rows-2">volt_rows/2</a></h3>
<div class="spec">
<p><tt>volt_rows(ColumnTypes, Rows) -&gt; any()</tt></p>
</div><p>Encode Erlang terms to VoltTable rows.</p>

<h3 class="function"><a name="volt_short-1">volt_short/1</a></h3>
<div class="spec">
<p><tt>volt_short(E) -&gt; any()</tt></p>
</div><p>Erlang integer to VoltDB SHORTINT (16 bit) wire code.</p>

<h3 class="function"><a name="volt_small-1">volt_small/1</a></h3>
<div class="spec">
<p><tt>volt_small(E) -&gt; any()</tt></p>
</div><p>Erlang integer to VoltDB SHORTINT (16 bit) wire code.</p>

<h3 class="function"><a name="volt_string-1">volt_string/1</a></h3>
<div class="spec">
<p><tt>volt_string(V) -&gt; any()</tt></p>
</div><p>VoltDB string wire code for NULL</p>

<h3 class="function"><a name="volt_table-1">volt_table/1</a></h3>
<div class="spec">
<p><tt>volt_table(X1) -&gt; any()</tt></p>
</div><p>Encode Erlang terms to VoltTable rows, with status code 0.</p>

<h3 class="function"><a name="volt_table-2">volt_table/2</a></h3>
<div class="spec">
<p><tt>volt_table(X1, StatusCode) -&gt; any()</tt></p>
</div><p>Encode Erlang terms to VoltTable rows, with explicit status code.</p>

<h3 class="function"><a name="volt_time-1">volt_time/1</a></h3>
<div class="spec">
<p><tt>volt_time(UTC) -&gt; any()</tt></p>
</div><p>Erlang 'now format' time to VoltDB wire code time binary.</p>

<h3 class="function"><a name="volt_time_binary-1">volt_time_binary/1</a></h3>
<div class="spec">
<p><tt>volt_time_binary(MilliEpoch) -&gt; any()</tt></p>
</div><p>Over/Underrun guards and cast to binary</p>

<h3 class="function"><a name="volt_type-1">volt_type/1</a></h3>
<div class="spec">
<p><tt>volt_type(X) -&gt; any()</tt></p>
</div><p> Guessing types.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, May 26 2010, 03:10:55.</i></p>
</body>
</html>
